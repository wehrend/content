---
title: 11_Clocks_flipflops_and_registers (de)
date: 2022-03-12
category:
link:
description:
type: text
menu:
  docs:
    parent: "digital_logic_2"
    weight: 10
---

== Taktgeber, Flipflops und Register
In diesem Blogbeitrag stellt der Autor mehrere Elemente vor, die zu einem spÃ¤teren Zeitpunkt benÃ¶tigt werden
.


=== Register-Transfer-Level benÃ¶tigt eine Taktquelle
Bisher haben wir nur die kombinatorische Logik kennengelernt, die
ohne Taktquelle auskommt â€“ jedes Signal wird nur um die Zeit verzÃ¶gert, die es
fÃ¼r die Ãœbertragung durch den Schaltkreis benÃ¶tigt. Dies wird als asynchron bezeichnet.
FÃ¼r anspruchsvollere Aufgaben, wie sequentielle Schaltkreise, sind jedoch Register erforderlich,
 die die Eingangs- und Ausgangssignale speichern,
um korrekte Ergebnisse zu erzielen. Dies wird als synchron bezeichnet.
Die meisten, wenn nicht sogar alle heutzutage verwendeten Designs sind synchron, da diese weniger komplex sind.


*Register-Transfer-Level*


image:../images/how_does_cpu/rtl_scheme.svg[width=â€100%â€œ]

Die blauen Teile im Bild oben zeigen Register, in denen die Werte
gespeichert werden. Wir werden spÃ¤ter sehen, wie diese implementiert werden. Schauen wir uns zunÃ¤chst
die benÃ¶tigte Taktquelle an.

Es gibt verschiedene MÃ¶glichkeiten, eine Taktquelle zu erzeugen:

. Ein Quarzoszillator
. Ein Ringoszillator

Ersterer ist die klassische, letzterer eine modernere Variante.

[cols=â€a,aâ€œ width=â€100%â€œ]
|===
| *Quarzoszillator* | *Ringoszillator*
|image:../images/how_does_cpu/crystal_symbol.svg[width=â€80%â€œ]
|image:../images/how_does_cpu/inverter_chain_symbol.svg[width=â€80%â€œ]
|typischer Frequenzbereich: 1Mhz..100Mhz | typischer Frequenzbereich: 1Hz..15Mhz(diskretes Layout)
|image:../images/how_does_cpu/pierce_gate_circuit.svg[width=â€350pxâ€œ]
|image:../images/how_does_cpu/inverter_chain.svg[width=â€350pxâ€œ]
| Frequenz wird durch Kristallgeometrie bestimmt
| Frequenz wird durch Laufzeit und Anzahl der Gates bestimmt
| Genauigkeit hÃ¤ngt hauptsÃ¤chlich von der Temperatur ab; fÃ¼r prÃ¤zise Anwendungen werden KristallÃ¶fen verwendet
| Genauigkeit hÃ¤ngt hauptsÃ¤chlich von der StabilitÃ¤t der Stromversorgung ab
|===

==== Der Kristalloszillator
Der Kristalloszillator ist eine Taktquelle, die auf einem Quarzkristall basiert.
Die Frequenz hÃ¤ngt von der Geometrie des Quarzes ab.
Quarzoszillatoren sind in einem MetallgehÃ¤use mit
zusÃ¤tzlicher Verdrahtung erhÃ¤ltlich, wobei der Quarz das HerzstÃ¼ck des Schaltkreises bildet.
Der Schaltkreis basiert in der Regel auf dem https://en.wikipedia.org/wiki/Pierce_oscillator[Pierce-Oszillator].

image:../images/how_does_cpu/pierce_gate_circuit.svg[width=â€400pxâ€œ]

Ihre Genauigkeit hÃ¤ngt hauptsÃ¤chlich von der Temperatur ab. FÃ¼r Anwendungen mit hohen Genauigkeitsanforderungen
werden sie daher in einem Quarzofen untergebracht, der den Quarz auf einer konstanten Temperatur hÃ¤lt.
Eine interessante Zerlegung eines solchen Oszillators ist auf http://www.righto.com/2021/02/teardown-of-quartz-crystal-oscillator.html [Ken Shirriffs Blog] verfÃ¼gbar.


==== Der Ringoszillator
Eine weitere gÃ¤ngige Taktgeberquelle ist der Ringoszillator.
Der Trick besteht darin, eine ungerade Anzahl von Inverter-Gates zu verketten und den Ausgang des letzten Inverters als Eingang
fÃ¼r den ersten Inverter zu verwenden. Auf diese Weise entsteht ein Schwingkreis.

image:../images/how_does_cpu/inverter_chain.svg[width=â€400pxâ€œ]

Die Frequenz hÃ¤ngt von der Anzahl der Inverter sowie von der Laufzeit Tp ab (siehe Gleichung unten). Die Zeit, die das Signal benÃ¶tigt, um
durch das Gate zu laufen, wird als Laufzeit Tp bezeichnet.

[role=â€imageâ€œ,â€../images/how_does_cpu/ring_oscillator_frequency.svgâ€œ,imgfmt=â€svgâ€œ, width=â€40%â€œ]
\[f_{ro} = \frac{1}{2nT_{p}}\]

Hier hÃ¤ngt die Genauigkeit hauptsÃ¤chlich von der StabilitÃ¤t der Stromversorgung ab.
Ein Anwendungsbeispiel â€“ z. B. die 8087, die Gleitkommaeinheit von IntelÂ® â€“ wird erneut von
http://www.righto.com/2018/08/inside-die-of-intels-8087-coprocessor.html[Ken Shirriffs Blog].
 Wie dort gezeigt, kann die Frequenz durch HinzufÃ¼gen eines RC-Netzwerks zwischen den Invertern verringert werden.



==== Das klassische RS-Flipflop

Das klassische Flipflop besteht aus zwei NAND-Gattern, deren AusgÃ¤nge an das komplementÃ¤re Gatter rÃ¼ckgekoppelt werden,
 wie in der folgenden Tabelle zu sehen ist. Unterhalb der Schaltung ist die Wahrheitstabelle angegeben.
Wie zu sehen ist, sperrt das Flipflop den Ausgang auf einen Zustand, â€1â€œ oder â€0â€œ.
Wenn beide EingÃ¤nge auf â€niedrigâ€œ gesetzt sind, ist der Ausgang undefiniert (und entspricht der bevorzugten Position).

[cols=â€a,aâ€œ width=â€100%â€œ]
|===
| *RS-Flipflop-Struktur* | *RS-Flipflop-Symbol*
|image:../images/how_does_cpu/flipflop_circuit.svg[width=â€80%â€œ]
|image:../images/how_does_cpu/flipflop_symbol.svg[width=â€80%â€œ]
|===

[width=â€50%â€œ]
|===
|Ì…R | Ì…S || Q | Ì…Q | comments
| 0 | 0 | 1 | 1 | invalid
| 0 | 1 | 1 | 0 | Reset
| 1 | 0 | 0 | 1 | Setzen
| 1 | 1 | Q | Î©Q | --
|===
Eine Anwendung des klassischen RS-Flipflops ist die Entprellung von Schaltern.

FÃ¼r die meisten Anwendungen ist jedoch ein weiterentwickeltes Flipflop erforderlich. Sehen wir uns
das (D)ata-Flipflop an.

==== Das D-Flipflop

Beim D-Flipflop wird der Schaltung des RS-Flipflops zwei NAND-Gatter vorgeschaltet,
die durch einen Taktimpuls gesteuert werden. Nur wenn der Takt hoch ist (d. h. â€1â€œ), ist das
am (D)ata-Eingang anliegende Datum gÃ¼ltig und wird im RS-Flipflop gespeichert. Andernfalls ist das
anliegende Datum ungÃ¼ltig.

[cols=â€a,aâ€œ width=â€100%â€œ]
|===
| *D-Flipflop-Struktur* | *D-Flipflop-Symbol*
|image:../images/how_does_cpu/dflipflop_circuit.svg[width=â€80%â€œ]
|image:../images/how_does_cpu/dflipflop_symbol.svg[width=â€80%â€œ]
|===

[width=â€50%â€œ]
|===
|Clock | D | Q | Ì…Q | comments
| ğŸ “ >>0 | x | Q | â‚¯Q | keine Ã„nderung
| ğŸ “ >>0 | 1 | 1 | 0 | ZurÃ¼cksetzen
| ğŸ ‘ >>1 | 0 | 0 | 1 | Setzen
| ğŸ ‘ >>1 | 1 | Q | â‚¯Q | -
|===


=== Ein BinÃ¤rzÃ¤hler

Mit dem D-Flipflop, das wir im letzten Abschnitt kennengelernt haben,
kÃ¶nnen wir einen (asynchronen) BinÃ¤rzÃ¤hler konstruieren.
Dieser Ausgang kann als Adresse fÃ¼r eine ROM-Tabelle verwendet werden, wie wir in einem anderen Blogbeitrag sehen werden.

[cols=â€aâ€œ width=â€100%â€œ]
|===
| *Asynchroner BinÃ¤rzÃ¤hler mit D-Flipflops*
|image:../images/how_does_cpu/dflipflop_counter.svg[width=â€100%â€œ]
|===

Wenn man die AusgÃ¤nge unabhÃ¤ngig voneinander betrachtet, kann man sehen, dass der ZÃ¤hler
auch als Frequenzteiler funktioniert: Bei jedem Ausgang wird die Frequenz
im VerhÃ¤ltnis zu der vorherigen durch zwei geteilt.

== Register
Was sind Register? Register werden verwendet, um Werte zu halten bzw. zu speichern.
Jede heutzutage etwas komplexere CPU verfÃ¼gt Ã¼ber eine groÃŸe Anzahl von Registern.
Die RegistergrÃ¶ÃŸen variieren stark je nach Anwendung. Sie reichen von Statusregistern,
 die nur ein Bit enthalten, Ã¼ber Register mit mehr als 32 und 64 Bit fÃ¼r regulÃ¤re Register bis hin zu Vektorregistern
mit einer GrÃ¶ÃŸe von 64 Byte (= 512 Bit). Diese Register werden nach einem bestimmten Schema benannt
Schema benannt, in einigen Architekturen mit Zahlen (z. B. MIPS und ARM), in anderen FÃ¤llen mit einem
komplexeren Schema aus alphabetischen Zahlen (wie in x86-Architekturen).


image:../images/how_does_cpu/register.svg[width=â€100%â€œ]

In den vorherigen Abschnitten haben wir etwas Ã¼ber das Flipflop gelernt.
Dies sind die Bausteine der Register. Wie im Bild oben zu sehen ist,
wird jedes Flipflop mit demselben Signal getaktet.
Wir werden auch oft den Begriff Akkumulator verwenden.
Akkumulatoren sind Register, die gleichzeitig Quell- und Zielregister sind.
 So speichern sie z. B. bei einer Addition einen Eingabewert und
halten das Ergebnis nach der Operation im selben Register.

(translation: 2024-12-29)